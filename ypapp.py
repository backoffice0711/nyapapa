# -*- coding: utf-8 -*-
"""ypapp

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NbYhH6wwsqde-K3TsWUZhluTGU1hkxnQ
"""

!pip install yfinance --quiet

# Commented out IPython magic to ensure Python compatibility.
# 安裝 yfinance（抓上市/上櫃及美股歷史價格）和 ipywidgets（互動元件）
!pip install yfinance ipywidgets --quiet

# 載入核心函式庫
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import widgets, VBox, HBox, Layout
from IPython.display import display, clear_output

# 讓圖表在 Notebook 內顯示
# %matplotlib inline

def backtest_portfolio(
    tickers, weights, start_date, end_date,
    one_off=0, dca=0, dca_freq='M', rebalance_freq='M'
):
    # 1️⃣ 抓調整後收盤價
    prices = yf.download(
        tickers, start=start_date, end=end_date,
        auto_adjust=True
    )['Close']

    # 2️⃣ 計算日報酬，NA 直接當 0
    returns = prices.pct_change(fill_method=None).fillna(0)
    dates = prices.index

    # 3️⃣ 建立現金流
    cash_flow = pd.Series(0, index=dates)
    cash_flow.iloc[0] += one_off

    # 3a️⃣ DCA：真實每期第一個交易日
    dca_dates = [
        grp.index[0]
        for _, grp in prices.groupby(pd.Grouper(freq=dca_freq))
        if len(grp)>0
    ]
    for d in dca_dates:
        cash_flow.loc[d] += dca

    # 4️⃣ 模擬投組價值
    portfolio = pd.Series(index=dates, dtype=float)
    w = np.array(weights)
    portfolio.iloc[0] = cash_flow.iloc[0]  # 一開始的資金

    # 4a️⃣ 重平衡：真實每期最後一個交易日
    rebalance_dates = [
        grp.index[-1]
        for _, grp in prices.groupby(pd.Grouper(freq=rebalance_freq))
        if len(grp)>0
    ]

    for i in range(1, len(dates)):
        date = dates[i]
        # 昨日市值 × (1 + 日報酬) + 今日投入
        portfolio.iloc[i] = (
            portfolio.iloc[i-1] * (1 + np.dot(returns.iloc[i], w))
            + cash_flow.iloc[i]
        )
        # 如果是平衡日，就把權重「重設」
        if date in rebalance_dates:
            total = portfolio.iloc[i]
            w = np.array(weights)
            portfolio.iloc[i] = total

    return portfolio

# ➊ 標的輸入
tickers_txt = widgets.Text(
    value='2330.TW,00850.TW,VOO,AAPL',
    description='標的：', layout=Layout(width='70%')
)
weights_txt = widgets.Text(
    value='0.4,0.3,0.2,0.1',
    description='權重：', layout=Layout(width='70%')
)

# ➋ 資金設定
oneoff_num = widgets.FloatText(value=10000, description='一次性：')
dca_num    = widgets.FloatText(value=1000,  description='定額：')

# ➌ 週期選單
dca_freq = widgets.Dropdown(
    options=[('日','D'),('週','W'),('月','M'),('季','Q'),('年','A')],
    value='M', description='DCA：'
)
rebalance_freq = widgets.Dropdown(
    options=[('日','D'),('週','W'),('月','M'),('季','Q'),('年','A')],
    value='M', description='重平衡：'
)

# ➍ 時間範圍
start_dp = widgets.DatePicker(value=pd.to_datetime('2015-01-01'), description='開始日：')
end_dp   = widgets.DatePicker(value=pd.to_datetime('2025-06-07'), description='結束日：')

# ➎ 按鈕與結果區
run_btn = widgets.Button(description='執行回測', button_style='success')
out = widgets.Output()

# 把元件排版
ui = VBox([
    tickers_txt, weights_txt,
    HBox([oneoff_num, dca_num]),
    HBox([dca_freq, rebalance_freq]),
    HBox([start_dp, end_dp]),
    run_btn, out
])
display(ui)

def on_run(b):
    with out:
        clear_output()
        # 1️⃣ 解析輸入
        tickers = [t.strip() for t in tickers_txt.value.split(',')]
        weights = list(map(float, weights_txt.value.split(',')))
        start   = start_dp.value.strftime('%Y-%m-%d')
        end     = end_dp.value.strftime('%Y-%m-%d')

        # 2️⃣ 先抓資料檢查
        tmp = yf.download(tickers, start=start, end=end, auto_adjust=True)
        if tmp.empty:
            print("❌ 沒有抓到任何資料，請檢查代號或日期")
            return

        # 3️⃣ 跑回測
        pf = backtest_portfolio(
            tickers, weights, start, end,
            one_off=oneoff_num.value,
            dca=dca_num.value,
            dca_freq=dca_freq.value,
            rebalance_freq=rebalance_freq.value
        )

        # 4️⃣ 資產配置圓餅圖
        plt.figure(figsize=(5,5))
        plt.pie(weights, labels=tickers, autopct='%.1f%%', startangle=90)
        plt.title('資產配置比例')
        plt.show()

        # 5️⃣ 累積報酬率走勢 (%)
        pf_pct = (pf / pf.iloc[0] - 1) * 100
        plt.figure(figsize=(10,4))
        plt.plot(pf_pct.index, pf_pct.values, linewidth=2)
        plt.title('累積報酬率 (%)')
        plt.xlabel('日期'); plt.ylabel('累積報酬率 (%)')
        plt.grid(True)
        plt.show()

        # 6️⃣ 回撤走勢
        dd = pf / pf.cummax() - 1
        plt.figure(figsize=(10,3))
        plt.fill_between(dd.index, dd.values, 0,
                         where=dd<0, color='red', alpha=0.4)
        plt.title('回撤 (%)')
        plt.xlabel('日期'); plt.ylabel('Drawdown')
        plt.grid(True)
        plt.show()

        # 7️⃣ 關鍵指標表
        returns = tmp['Close'].pct_change().fillna(0)
        total_ret = pf.iloc[-1]/pf.iloc[0] - 1
        ann_ret   = (1 + total_ret)**(252/len(pf)) - 1
        vol       = returns.dot(weights).std() * np.sqrt(252)
        sharpe    = ann_ret / vol if vol>0 else np.nan
        max_dd    = dd.min()

        import pandas as pd
        stats = pd.DataFrame({
            '指標': ['期間累積報酬','年化報酬率','年化波動度','夏普比率','最大回撤'],
            '數值': [
                f"{total_ret*100:.2f}%",
                f"{ann_ret*100:.2f}%",
                f"{vol*100:.2f}%",
                f"{sharpe:.2f}",
                f"{max_dd*100:.2f}%"
            ]
        })
        display(stats)

# 重新綁定按鈕
run_btn.on_click(on_run)